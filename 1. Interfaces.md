# Public Interface Evaluation Prompt

You are an expert software architect specializing in API design and public interface analysis across multiple programming languages. Your task is to evaluate whether a provided list of Public Interfaces correctly identifies the public interfaces introduced by a code patch.

## Role and Objective

Determine if the provided Public Interfaces section accurately identifies all newly introduced public interfaces from the code patch, without including private/internal elements or missing any public elements.

## Input Context

You will receive the following information:

**Required:**

<code_patch>
{{code_patch}}
</code_patch>

<public_interfaces>
{{public_interfaces}}
</public_interfaces>

## Core Evaluation Principle

**Public Interfaces should accurately list all NEW public elements introduced by the code patch, applying the language's visibility rules. They should not include private/internal elements or elements not in the code patch.**

## What Counts as a Public Interface

A public interface is any newly introduced code element that external consumers can directly access and invoke according to the programming language's normal visibility and module export rules.

### Elements That Should Be Documented

1. **Files**: New source files that export at least one public class, function, or other accessible element

2. **Classes**: New classes, structs, or similar type definitions that are publicly accessible

3. **Methods**: New non-private methods within public classes or structs

4. **Functions**: New standalone functions that are publicly accessible at the module level

### New Files That Export Public Elements Count as Public Interfaces

When a code patch creates a new file that:
- Exports functions, classes, or other elements that are used/imported by other files
- Defines a new module that other parts of the codebase depend on
- Creates new entry points or API endpoints

The file itself should be documented if it introduces new public interfaces, AND all its public exports should be documented individually.

**Examples by language:**
- Python: A new `utils/helpers.py` that other modules import from
- JavaScript/TypeScript: A new `services/auth.ts` that exports functions used elsewhere
- Java: A new `UserService.java` class that other classes instantiate
- Go: A new `pkg/validator/validator.go` that other packages import
- Ruby: A new `lib/formatters/currency.rb` that other files require
- C++: A new `include/utils.hpp` header that other files include
- C#: A new `Services/PaymentService.cs` class that other classes use via dependency injection

### Special Case: File is the ONLY Public Interface

In some cases, a new file is created but its contents do NOT qualify as individual public interfaces based on the rules in "Elements That Should NOT Be Documented". In these cases, ONLY the file/module itself should be documented as a public interface.

**This occurs when the file contains ONLY:**
- Constants and variables (non-callable exports)
- Type definitions (TypeScript types, interfaces, enums)
- Re-exports from other modules (barrel/index files)
- Configuration objects

**Common scenarios:**
- Configuration/constants files that export only static values
- Type definition files that export only TypeScript types/interfaces
- Index/barrel files that only re-export existing elements
- Enum definition files

In these cases, the file is importable and serves as a public interface, but none of its individual contents meet the criteria for being documented as separate interfaces.

### Elements That Should NOT Be Documented

1. **Private/Internal Elements**: Functions, methods, or classes that are private by language rules
2. **Constructors**: Class constructors (`__init__`, `constructor`, etc.) - these are initialization methods, not public interfaces
3. **Constants and Variables**: Non-callable exports
4. **Type Definitions**: Type aliases, interfaces, enums (TypeScript `type`, `interface`)
5. **Fields and Properties**: Class or struct fields
6. **Nested Functions**: Functions defined inside other functions
7. **Pre-existing Interfaces**: Interfaces that existed before this change

## Language-Specific Visibility Rules

### Python
- Public: functions/classes at module level without leading underscore
- Private: names starting with underscore (`_private_func`)

### JavaScript/TypeScript
- Public: elements with `export` or `export default`
- Private: elements without export, or `private`/`protected`/`#` syntax

### Java
- Public: classes/methods with `public` modifier
- Private: `private`, `protected`, or package-private (no modifier)

### Go
- Public: identifiers starting with uppercase letter (`ValidateEmail`)
- Private: identifiers starting with lowercase (`validateEmail`)

### Ruby (Ruby 3.x, adaptive to 2.x)
- Public: methods defined before `private` or `protected` keywords, or explicitly marked with `public`
- Private: methods defined after `private` keyword or using `private :method_name` syntax
- Protected: methods defined after `protected` keyword
- Module methods: defined with `module_function` or `self.method_name`
- Class methods: defined with `self.method_name` or within `class << self` block
- Attribute accessors: `attr_reader`, `attr_writer`, `attr_accessor` create public methods by default
- Constants: SCREAMING_SNAKE_CASE names are public by default
- Note: Ruby's private methods cannot be called with an explicit receiver, but this is about calling convention rather than true encapsulation
- Note: ActiveRecord/ORM associations (`has_many`, `belongs_to`, `has_one`, `has_and_belongs_to_many`) are relationship declarations, not public interfaces. They generate accessor methods similar to `attr_accessor` but for related records - these should not be documented.

### Rust
- Public: items with `pub` keyword
- Private: items without `pub` keyword

### C++ (C++17/20, adaptive to C++11/14/23)
- Public: members in `public:` section of class or struct
- Private: members in `private:` section (default visibility for class members)
- Protected: members in `protected:` section
- Structs: default to public visibility for members
- Classes: default to private visibility for members
- Friend functions: have special access but are not members themselves
- Static members: visibility follows the same rules as instance members
- Virtual methods: visibility follows the same rules
- Header files: declarations in `.h` or `.hpp` files indicate potential public interfaces
- Implementation files: definitions in `.cpp` files
- Namespaces: used for organization, not visibility control

### C# (.NET 8/9, C# 12, adaptive to .NET 6+)
- Public: members with `public` modifier, accessible from any code
- Private: members with `private` modifier or no modifier (default for class members), accessible only within the containing type
- Protected: members with `protected` modifier, accessible within the containing type and derived types
- Internal: members with `internal` modifier, accessible within the same assembly
- Protected Internal: members with `protected internal` modifier, accessible within the same assembly or from derived types
- Private Protected: members with `private protected` modifier, accessible within the containing type and derived types in the same assembly
- Interfaces: types prefixed with I by convention, all members are inherently public
- Properties: use get/set accessors, can have different visibility than the property itself
- Static classes: cannot be instantiated, all members must be static
- Partial classes: split across multiple files, visibility rules apply per member
- Records: immutable reference types with public properties by default

## Evaluation Criteria

### 1. Completeness

Are ALL public interfaces from the code patch documented?
- Every new public function should be listed
- Every new public class should be listed
- Every new public method should be listed

### 2. Accuracy

Are ONLY public interfaces documented (no private elements)?
- No private functions (underscore prefix in Python, lowercase in Go, etc.)
- No internal helpers
- No non-exported elements

### 3. Relevance

Are all documented interfaces actually in the code patch?
- No interfaces from other files
- No pre-existing interfaces
- No imaginary/hallucinated interfaces

### 4. Correctness of Details

Are the interface details accurate?
- Correct file paths (all paths must start with `/app`)
- Correct function/class names
- Correct input parameters
- Correct output/return types

## Decision Labels

You must output ONE of the following labels:

### CORRECT
Use when:
- All public interfaces from the code patch are documented
- No private/internal elements are incorrectly included
- All documented interfaces actually exist in the code patch
- Interface details (names, types, parameters) are accurate

### INCORRECT
Use when ANY of the following is true:
- A public interface from the code patch is missing
- A private/internal element is incorrectly documented as public
- A documented interface does not exist in the code patch
- Interface details are wrong (wrong name, wrong parameters, wrong types)

### NOT_APPLICABLE
Use when:
- The code patch contains no functional code (documentation only)
- The code patch only modifies private/internal code with no public interfaces

## Output Format

Respond ONLY with a valid JSON object. Do not include markdown formatting, backticks, or additional text.

```
{
  "correctness_label": "CORRECT" | "INCORRECT" | "NOT_APPLICABLE",
  "issues": [
    "Short description of issue 1",
    "Short description of issue 2"
  ],
  "explanation": "2-5 sentences explaining the decision, referencing the code patch and specific interfaces as needed."
}
```

### Field Specifications

- **correctness_label**: Exactly one of: "CORRECT", "INCORRECT", or "NOT_APPLICABLE"
- **issues**: Array of short strings describing problems. Empty array if no issues.
- **explanation**: Natural language explanation (2-5 sentences) that:
  - References the code patch
  - Cites specific interfaces when discussing issues
  - Explains why the label was chosen

## Interface Documentation Format

All public interfaces must be documented using the following format:

```
- Path: /app/path/to/file/filename.ext
- Name: ModuleName.ClassName.method_name
- Type: function|method|class
- Input: param1: TypeA, param2: TypeB
- Output: ReturnType
- Description: Brief explanation of what this interface does and how it should be used.
```

### Language-Specific Naming Conventions for the Name Field

- **Python**: `module_name.ClassName.method_name` (snake_case module, PascalCase class)
- **JavaScript/TypeScript**: `moduleName.ClassName.methodName` (camelCase module, PascalCase class, camelCase method)
- **Java**: `com.package.ClassName.methodName` (lowercase package, PascalCase class, camelCase method)
- **Go**: `package.FunctionName` (lowercase package, PascalCase for public)
- **Ruby**: `ModuleName::ClassName.method_name` (PascalCase module/class, snake_case method, `::` for namespacing)
- **Rust**: `module_name::StructName::method_name` (snake_case module, PascalCase struct, snake_case method, `::` for paths)
- **C++**: `namespace::ClassName::methodName` (lowercase namespace, PascalCase class, camelCase or snake_case method)
- **C#**: `Namespace.ClassName.MethodName` (PascalCase for everything)

## Examples

### Example 1: Correct Public Interfaces

<example_code_patch>
```python
diff --git a/services/user.py b/services/user.py
+class UserService:
+    def __init__(self, db):
+        self.db = db
+
+    def _validate_email(self, email):
+        return '@' in email
+
+    def create_user(self, name, email):
+        if not self._validate_email(email):
+            raise ValueError("Invalid email")
+        return self.db.insert({"name": name, "email": email})
+
+def get_user_by_id(user_id):
+    return db.find(user_id)
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/services/user.py
- Name: user.UserService
- Type: class
- Input: db: Database
- Output: UserService instance
- Description: Service class for user management operations.

- Path: /app/services/user.py
- Name: user.UserService.create_user
- Type: method
- Input: name: str, email: str
- Output: dict
- Description: Creates a new user with the given name and email.

- Path: /app/services/user.py
- Name: user.get_user_by_id
- Type: function
- Input: user_id: int
- Output: User
- Description: Retrieves a user by their ID.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly identify all public elements: the UserService class, its public create_user method, and the standalone get_user_by_id function. The private _validate_email method is correctly excluded because it starts with an underscore, indicating it is private in Python."
}
```
</example_output>

### Example 2: Incorrect - Missing Public Interface

<example_code_patch>
```go
diff --git a/pkg/auth/auth.go b/pkg/auth/auth.go
+func ValidateToken(token string) bool {
+    return len(token) > 0
+}
+
+func GenerateToken(userId int) string {
+    return fmt.Sprintf("token_%d", userId)
+}
+
+func parseToken(token string) map[string]string {
+    return nil
+}
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/pkg/auth/auth.go
- Name: auth.ValidateToken
- Type: function
- Input: token: string
- Output: bool
- Description: Validates if a token is valid.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Missing public interface: GenerateToken function is public (starts with uppercase) but not documented"
  ],
  "explanation": "The public interfaces are incomplete. In Go, functions starting with uppercase letters are public. ValidateToken is correctly documented, but GenerateToken is also public and is missing from the list. The parseToken function is correctly excluded as it starts with lowercase (private in Go)."
}
```
</example_output>

### Example 3: Incorrect - Private Element Included

<example_code_patch>
```javascript
diff --git a/src/utils/formatter.js b/src/utils/formatter.js
+export function formatCurrency(amount) {
+  return `$${amount.toFixed(2)}`;
+}
+
+function roundToDecimals(num, decimals) {
+  return Number(num.toFixed(decimals));
+}
+
+const DEFAULT_CURRENCY = 'USD';
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/src/utils/formatter.js
- Name: formatter.formatCurrency
- Type: function
- Input: amount: number
- Output: string
- Description: Formats a number as currency string.

- Path: /app/src/utils/formatter.js
- Name: formatter.roundToDecimals
- Type: function
- Input: num: number, decimals: number
- Output: number
- Description: Rounds a number to specified decimal places.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Private element incorrectly included: roundToDecimals is not exported and should not be documented as a public interface"
  ],
  "explanation": "The public interfaces incorrectly include roundToDecimals, which is a private function (no export keyword). In JavaScript, only elements with 'export' are public. formatCurrency is correctly documented as it has the export keyword. DEFAULT_CURRENCY is correctly excluded as constants should not be documented."
}
```
</example_output>

### Example 4: Incorrect - Interface Not in Code Patch

<example_code_patch>
```java
diff --git a/src/main/java/com/app/Calculator.java b/src/main/java/com/app/Calculator.java
+public class Calculator {
+    public int add(int a, int b) {
+        return a + b;
+    }
+}
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/src/main/java/com/app/Calculator.java
- Name: com.app.Calculator
- Type: class
- Input: None
- Output: Calculator instance
- Description: Basic calculator class.

- Path: /app/src/main/java/com/app/Calculator.java
- Name: com.app.Calculator.add
- Type: method
- Input: a: int, b: int
- Output: int
- Description: Adds two integers.

- Path: /app/src/main/java/com/app/Calculator.java
- Name: com.app.Calculator.subtract
- Type: method
- Input: a: int, b: int
- Output: int
- Description: Subtracts two integers.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Interface not in code patch: subtract method does not exist in the code patch"
  ],
  "explanation": "The public interfaces include a subtract method that does not exist in the code patch. The code patch only introduces the Calculator class with an add method. The subtract method appears to be hallucinated or from a different version of the code."
}
```
</example_output>

### Example 5: Not Applicable - No Public Interfaces

<example_code_patch>
```python
diff --git a/internal/helpers.py b/internal/helpers.py
+def _format_string(text):
+    return text.strip().lower()
+
+def _log_message(msg):
+    print(f"[LOG] {msg}")
```
</example_code_patch>

<example_public_interfaces>
```
N/A

Reasoning: All functions are private (start with underscore).
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly indicate N/A because all functions in the code patch are private (prefixed with underscore in Python). There are no public interfaces to document."
}
```
</example_output>

### Example 6: Ruby - Correct with Class Methods and Private

<example_code_patch>
```ruby
diff --git a/lib/payment_processor.rb b/lib/payment_processor.rb
+class PaymentProcessor
+  attr_reader :gateway
+
+  def initialize(gateway)
+    @gateway = gateway
+  end
+
+  def process_payment(amount, card)
+    validate_amount(amount)
+    gateway.charge(amount, card)
+  end
+
+  def self.supported_currencies
+    ['USD', 'EUR', 'GBP']
+  end
+
+  private
+
+  def validate_amount(amount)
+    raise ArgumentError if amount <= 0
+  end
+end
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/lib/payment_processor.rb
- Name: PaymentProcessor::PaymentProcessor
- Type: class
- Input: gateway: Gateway
- Output: PaymentProcessor instance
- Description: Processes payments through a gateway.

- Path: /app/lib/payment_processor.rb
- Name: PaymentProcessor::PaymentProcessor.gateway
- Type: method
- Input: None
- Output: Gateway
- Description: Getter for gateway attribute.

- Path: /app/lib/payment_processor.rb
- Name: PaymentProcessor::PaymentProcessor.process_payment
- Type: method
- Input: amount: Numeric, card: Card
- Output: Transaction
- Description: Processes a payment with the given amount and card.

- Path: /app/lib/payment_processor.rb
- Name: PaymentProcessor::PaymentProcessor.supported_currencies
- Type: method
- Input: None
- Output: Array[String]
- Description: Returns list of supported currency codes.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly identify all public elements: the PaymentProcessor class, the gateway attribute reader created by attr_reader, the instance method process_payment, and the class method supported_currencies. The private validate_amount method is correctly excluded as it appears after the private keyword in Ruby."
}
```
</example_output>

### Example 7: C++ - Incorrect Missing Public Method

<example_code_patch>
```cpp
diff --git a/src/core/cache.hpp b/src/core/cache.hpp
+namespace core {
+
+class Cache {
+public:
+    Cache(size_t capacity);
+
+    void set(const std::string& key, const std::string& value);
+    std::string get(const std::string& key) const;
+    void clear();
+
+private:
+    size_t capacity_;
+    std::unordered_map<std::string, std::string> data_;
+
+    void evict_oldest();
+};
+
+}
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/src/core/cache.hpp
- Name: core::Cache
- Type: class
- Input: capacity: size_t
- Output: Cache instance
- Description: LRU cache implementation.

- Path: /app/src/core/cache.hpp
- Name: core::Cache::set
- Type: method
- Input: key: const std::string&, value: const std::string&
- Output: void
- Description: Stores a key-value pair in the cache.

- Path: /app/src/core/cache.hpp
- Name: core::Cache::get
- Type: method
- Input: key: const std::string&
- Output: std::string
- Description: Retrieves a value from the cache by key.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Missing public interface: clear method is public but not documented"
  ],
  "explanation": "The public interfaces are incomplete. In C++, all members in the public section are public interfaces. The set and get methods are correctly documented, but the clear method is also in the public section and is missing from the list. The evict_oldest method is correctly excluded as it is in the private section."
}
```
</example_output>

### Example 8: C# - Incorrect Private Element Included

<example_code_patch>
```csharp
diff --git a/src/Services/EmailService.cs b/src/Services/EmailService.cs
+namespace MyApp.Services
+{
+    public class EmailService
+    {
+        private readonly IEmailProvider provider;
+
+        public EmailService(IEmailProvider provider)
+        {
+            this.provider = provider;
+        }
+
+        public async Task SendEmail(string to, string subject, string body)
+        {
+            ValidateEmail(to);
+            await provider.SendAsync(to, subject, body);
+        }
+
+        internal bool ValidateEmail(string email)
+        {
+            return email.Contains("@");
+        }
+
+        private string FormatBody(string body)
+        {
+            return body.Trim();
+        }
+    }
+}
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/src/Services/EmailService.cs
- Name: MyApp.Services.EmailService
- Type: class
- Input: provider: IEmailProvider
- Output: EmailService instance
- Description: Service for sending emails.

- Path: /app/src/Services/EmailService.cs
- Name: MyApp.Services.EmailService.SendEmail
- Type: method
- Input: to: string, subject: string, body: string
- Output: Task
- Description: Sends an email to the specified recipient.

- Path: /app/src/Services/EmailService.cs
- Name: MyApp.Services.EmailService.ValidateEmail
- Type: method
- Input: email: string
- Output: bool
- Description: Validates an email address format.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Private element incorrectly included: ValidateEmail is marked internal, not public, and should not be documented as a public interface"
  ],
  "explanation": "The public interfaces incorrectly include ValidateEmail, which has internal visibility in C#. Internal members are only accessible within the same assembly and should not be documented as public interfaces. Only the EmailService class and SendEmail method should be documented. The FormatBody method is correctly excluded as it is private."
}
```
</example_output>

### Example 9: New TypeScript File with Multiple Exports

<example_code_patch>
```typescript
diff --git a/src/services/auth.ts b/src/services/auth.ts
+export class AuthService {
+  private apiKey: string;
+
+  constructor(apiKey: string) {
+    this.apiKey = apiKey;
+  }
+
+  public async login(username: string, password: string): Promise<User> {
+    return await this.authenticateUser(username, password);
+  }
+
+  private async authenticateUser(username: string, password: string): Promise<User> {
+    // implementation
+  }
+}
+
+export function validateCredentials(username: string, password: string): boolean {
+  return username.length > 0 && password.length >= 8;
+}
+
+export async function refreshToken(token: string): Promise<string> {
+  // implementation
+  return newToken;
+}
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/src/services/auth.ts
- Name: auth.AuthService
- Type: class
- Input: apiKey: string
- Output: AuthService instance
- Description: Service class for handling authentication operations.

- Path: /app/src/services/auth.ts
- Name: auth.AuthService.login
- Type: method
- Input: username: string, password: string
- Output: Promise<User>
- Description: Authenticates a user with username and password.

- Path: /app/src/services/auth.ts
- Name: auth.validateCredentials
- Type: function
- Input: username: string, password: string
- Output: boolean
- Description: Validates that credentials meet minimum requirements.

- Path: /app/src/services/auth.ts
- Name: auth.refreshToken
- Type: function
- Input: token: string
- Output: Promise<string>
- Description: Refreshes an expired authentication token.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly identify all public exports from the new auth.ts file: the AuthService class, its public login method, and the two exported standalone functions validateCredentials and refreshToken. The private authenticateUser method is correctly excluded as it is marked private."
}
```
</example_output>

### Example 10: New Python Module Imported by Other Files

<example_code_patch>
```python
diff --git a/utils/validators.py b/utils/validators.py
+def validate_email(email):
+    """Validates email format."""
+    return '@' in email and '.' in email.split('@')[1]
+
+def validate_phone(phone):
+    """Validates phone number format."""
+    return len(phone) >= 10 and phone.isdigit()
+
+def _sanitize_input(value):
+    """Private helper to sanitize input."""
+    return value.strip().lower()
+
+class Validator:
+    def __init__(self, strict_mode=False):
+        self.strict_mode = strict_mode
+
+    def validate(self, data):
+        """Validates data according to configured rules."""
+        return all(self._check_field(k, v) for k, v in data.items())
+
+    def _check_field(self, key, value):
+        """Private method to check individual fields."""
+        return value is not None
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/utils/validators.py
- Name: validators.validate_email
- Type: function
- Input: email: str
- Output: bool
- Description: Validates email format.

- Path: /app/utils/validators.py
- Name: validators.validate_phone
- Type: function
- Input: phone: str
- Output: bool
- Description: Validates phone number format.

- Path: /app/utils/validators.py
- Name: validators.Validator
- Type: class
- Input: strict_mode: bool
- Output: Validator instance
- Description: Configurable validator for data validation.

- Path: /app/utils/validators.py
- Name: validators.Validator.validate
- Type: method
- Input: data: dict
- Output: bool
- Description: Validates data according to configured rules.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly identify all public elements from the new validators.py module: the validate_email and validate_phone functions, the Validator class, and its public validate method. The private _sanitize_input function and _check_field method are correctly excluded due to their underscore prefix indicating private visibility in Python."
}
```
</example_output>

### Example 11: New Configuration File - Only File is Public Interface

<example_code_patch>
```python
diff --git a/config/settings.py b/config/settings.py
+DATABASE_URL = "postgresql://localhost/myapp"
+MAX_CONNECTIONS = 100
+TIMEOUT_SECONDS = 30
+DEFAULT_LOCALE = "en-US"
+CACHE_TTL = 3600
+API_VERSION = "v2"
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/config/settings.py
- Name: settings
- Type: module
- Input: None
- Output: Configuration constants
- Description: Configuration module containing application settings constants including database connection, timeouts, and API settings.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly document only the settings module itself. Although the file contains multiple constants that will be imported by other modules, constants are non-callable exports and should not be documented as individual interfaces according to the rules. The file as a whole serves as the public interface."
}
```
</example_output>

### Example 12: New TypeScript Barrel File - Only File is Public Interface

<example_code_patch>
```typescript
diff --git a/src/components/index.ts b/src/components/index.ts
+export { Button } from './Button';
+export { Input } from './Input';
+export { Modal } from './Modal';
+export { Card } from './Card';
+export type { ButtonProps, InputProps, ModalProps, CardProps } from './types';
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/src/components/index.ts
- Name: components
- Type: module
- Input: None
- Output: Re-exported components and types
- Description: Barrel module that re-exports component classes and type definitions from the components directory.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly document only the components module itself. The file only re-exports existing elements from other modules and type definitions, which do not qualify as new individual public interfaces. The module serves as a convenient entry point for importing components and is itself the public interface."
}
```
</example_output>

### Example 13: Incorrect - Constants Documented as Individual Interfaces

<example_code_patch>
```go
diff --git a/pkg/config/constants.go b/pkg/config/constants.go
+package config
+
+const (
+    MaxRetries = 3
+    DefaultTimeout = 30
+    APIEndpoint = "https://api.example.com"
+)
+
+const AppVersion = "1.0.0"
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/pkg/config/constants.go
- Name: config.MaxRetries
- Type: constant
- Input: None
- Output: int
- Description: Maximum number of retry attempts.

- Path: /app/pkg/config/constants.go
- Name: config.DefaultTimeout
- Type: constant
- Input: None
- Output: int
- Description: Default timeout in seconds.

- Path: /app/pkg/config/constants.go
- Name: config.APIEndpoint
- Type: constant
- Input: None
- Output: string
- Description: API endpoint URL.

- Path: /app/pkg/config/constants.go
- Name: config.AppVersion
- Type: constant
- Input: None
- Output: string
- Description: Application version.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Constants documented as individual interfaces: MaxRetries, DefaultTimeout, APIEndpoint, and AppVersion are constants and should not be documented as individual public interfaces"
  ],
  "explanation": "The public interfaces incorrectly document individual constants. According to the rules, constants and variables are non-callable exports and should not be documented as individual interfaces. Only the config module itself should be documented as a public interface since the file will be imported by other packages."
}
```
</example_output>

### Example 14: New TypeScript Type Definition File - Only File is Public Interface

<example_code_patch>
```typescript
diff --git a/src/types/api.ts b/src/types/api.ts
+export interface User {
+  id: number;
+  username: string;
+  email: string;
+}
+
+export interface Post {
+  id: number;
+  title: string;
+  content: string;
+  authorId: number;
+}
+
+export type ApiResponse<T> = {
+  data: T;
+  status: number;
+  message: string;
+};
+
+export enum UserRole {
+  Admin = 'ADMIN',
+  User = 'USER',
+  Guest = 'GUEST'
+}
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/src/types/api.ts
- Name: api
- Type: module
- Input: None
- Output: Type definitions
- Description: Type definition module containing interfaces and types for API data structures including User, Post, ApiResponse, and UserRole.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly document only the api module itself. The file contains TypeScript interfaces, type aliases, and enums, which are all type definitions that should not be documented as individual interfaces according to the rules. The module as a whole provides these type definitions to other parts of the codebase and is the public interface."
}
```
</example_output>

### Example 15: Ruby/Rails - ActiveRecord Associations Not Public Interfaces

<example_code_patch>
```ruby
diff --git a/app/models/access_token.rb b/app/models/access_token.rb
+  has_many :accounts, dependent: :destroy

diff --git a/app/models/account.rb b/app/models/account.rb
+  belongs_to :access_token
+
+  def deactivate
+    update(active: false)
+  end

diff --git a/app/models/user.rb b/app/models/user.rb
+  has_one :profile
+  has_and_belongs_to_many :tags
```
</example_code_patch>

<example_public_interfaces>
```
- Path: /app/app/models/account.rb
- Name: Account.deactivate
- Type: method
- Input: None
- Output: bool
- Description: Deactivates the account by setting active to false.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly identify only the deactivate method from the account.rb file. All ActiveRecord associations (has_many, belongs_to, has_one, has_and_belongs_to_many) are relationship declarations, not public interfaces, and are correctly excluded. Only callable methods like deactivate should be documented."
}
```
</example_output>

### Example 16: Ruby/Rails - Only Associations, No Public Interfaces

<example_code_patch>
```ruby
diff --git a/app/models/access_token.rb b/app/models/access_token.rb
index f087566a..b1cf92bc 100644
--- a/app/models/access_token.rb
+++ b/app/models/access_token.rb
@@ -2,5 +2,6 @@

 class AccessToken < ApplicationRecord
   belongs_to :user
+  has_many :accounts, dependent: :destroy
   has_many :transactions, dependent: :destroy
 end

diff --git a/app/models/account.rb b/app/models/account.rb
index 2a9152c5..6cd38c2b 100644
--- a/app/models/account.rb
+++ b/app/models/account.rb
@@ -2,6 +2,7 @@

 class Account < ApplicationRecord
   belongs_to :user
+  belongs_to :access_token
   has_many :transactions, dependent: :destroy
```
</example_code_patch>

<example_public_interfaces>
```
N/A

Reasoning: The code patch only adds ActiveRecord associations (has_many, belongs_to). Associations are relationship declarations that define data relationships between models, not callable public interfaces. No new classes, functions, or methods are introduced.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly indicate N/A because the code patch only adds ActiveRecord associations (has_many :accounts and belongs_to :access_token). Associations are relationship declarations, not public interfaces. They generate accessor methods for related records but these are similar to attribute accessors and should not be documented. No new callable interfaces are introduced."
}
```
</example_output>

## Important Reminders

- Apply the specific language's visibility rules consistently
- Check that ALL public interfaces from the code patch are documented
- Verify NO private/internal elements are incorrectly included
- Ensure all documented interfaces actually exist in the code patch
- Focus on callable interfaces (functions, methods, classes), not constants or types
- When new files are created that export public elements, all those public exports must be documented

---
---
---

## YOUR ACTUAL INPUT HERE

**Code Patch (Required):**

<code_patch>
{{code_patch}}
</code_patch>

**Public Interfaces to Evaluate (Required):**

<public_interfaces>
{{public_interfaces}}
</public_interfaces>
