# Public Interface Evaluation Prompt

You are an expert software architect specializing in API design and public interface analysis across multiple programming languages. Your task is to evaluate whether a provided list of Public Interfaces correctly identifies the public interfaces introduced by a code patch.

## Role and Objective

Determine if the provided Public Interfaces section accurately identifies all newly introduced public interfaces from the code patch, without including private/internal elements or missing any public elements.

## Input Context

You will receive the following information:

**Required:**

<code_patch>
{{code_patch}}
</code_patch>

<public_interfaces>
{{public_interfaces}}
</public_interfaces>

## Core Evaluation Principle

**Public Interfaces should accurately list all NEW public elements introduced by the code patch, applying the language's visibility rules. They should not include private/internal elements or elements not in the code patch.**

## What Counts as a Public Interface

A public interface is any newly introduced code element that external consumers can directly access and invoke according to the programming language's normal visibility and module export rules.

### Elements That Should Be Documented

1. **Files**: New source files that export at least one public class, function, or other accessible element

2. **Classes**: New classes, structs, or similar type definitions that are publicly accessible

3. **Methods**: New non-private methods within public classes or structs

4. **Functions**: New standalone functions that are publicly accessible at the module level

### Elements That Should NOT Be Documented

1. **Private/Internal Elements**: Functions, methods, or classes that are private by language rules
2. **Constructors**: Class constructors (`__init__`, `constructor`, etc.) - these are initialization methods, not public interfaces
3. **Constants and Variables**: Non-callable exports
4. **Type Definitions**: Type aliases, interfaces, enums (TypeScript `type`, `interface`)
5. **Fields and Properties**: Class or struct fields
6. **Nested Functions**: Functions defined inside other functions
7. **Pre-existing Interfaces**: Interfaces that existed before this change

## Language-Specific Visibility Rules

### Python
- Public: functions/classes at module level without leading underscore
- Private: names starting with underscore (`_private_func`)

### JavaScript/TypeScript
- Public: elements with `export` or `export default`
- Private: elements without export, or `private`/`protected`/`#` syntax

### Java
- Public: classes/methods with `public` modifier
- Private: `private`, `protected`, or package-private (no modifier)

### Go
- Public: identifiers starting with uppercase letter (`ValidateEmail`)
- Private: identifiers starting with lowercase (`validateEmail`)

### Ruby (Ruby 3.x, adaptive to 2.x)
- Public: methods defined before `private` or `protected` keywords, or explicitly marked with `public`
- Private: methods defined after `private` keyword or using `private :method_name` syntax
- Protected: methods defined after `protected` keyword
- Module methods: defined with `module_function` or `self.method_name`
- Class methods: defined with `self.method_name` or within `class << self` block
- Attribute accessors: `attr_reader`, `attr_writer`, `attr_accessor` create public methods by default
- Constants: SCREAMING_SNAKE_CASE names are public by default
- Note: Ruby's private methods cannot be called with an explicit receiver, but this is about calling convention rather than true encapsulation

### Rust
- Public: items with `pub` keyword
- Private: items without `pub` keyword

### C++ (C++17/20, adaptive to C++11/14/23)
- Public: members in `public:` section of class or struct
- Private: members in `private:` section (default visibility for class members)
- Protected: members in `protected:` section
- Structs: default to public visibility for members
- Classes: default to private visibility for members
- Friend functions: have special access but are not members themselves
- Static members: visibility follows the same rules as instance members
- Virtual methods: visibility follows the same rules
- Header files: declarations in `.h` or `.hpp` files indicate potential public interfaces
- Implementation files: definitions in `.cpp` files
- Namespaces: used for organization, not visibility control

### C# (.NET 8/9, C# 12, adaptive to .NET 6+)
- Public: members with `public` modifier, accessible from any code
- Private: members with `private` modifier or no modifier (default for class members), accessible only within the containing type
- Protected: members with `protected` modifier, accessible within the containing type and derived types
- Internal: members with `internal` modifier, accessible within the same assembly
- Protected Internal: members with `protected internal` modifier, accessible within the same assembly or from derived types
- Private Protected: members with `private protected` modifier, accessible within the containing type and derived types in the same assembly
- Interfaces: types prefixed with I by convention, all members are inherently public
- Properties: use get/set accessors, can have different visibility than the property itself
- Static classes: cannot be instantiated, all members must be static
- Partial classes: split across multiple files, visibility rules apply per member
- Records: immutable reference types with public properties by default

## Evaluation Criteria

### 1. Completeness

Are ALL public interfaces from the code patch documented?
- Every new public function should be listed
- Every new public class should be listed
- Every new public method should be listed

### 2. Accuracy

Are ONLY public interfaces documented (no private elements)?
- No private functions (underscore prefix in Python, lowercase in Go, etc.)
- No internal helpers
- No non-exported elements

### 3. Relevance

Are all documented interfaces actually in the code patch?
- No interfaces from other files
- No pre-existing interfaces
- No imaginary/hallucinated interfaces

### 4. Correctness of Details

Are the interface details accurate?
- Correct file paths (all paths must start with `/app`)
- Correct function/class names
- Correct input parameters
- Correct output/return types

## Decision Labels

You must output ONE of the following labels:

### CORRECT
Use when:
- All public interfaces from the code patch are documented
- No private/internal elements are incorrectly included
- All documented interfaces actually exist in the code patch
- Interface details (names, types, parameters) are accurate

### INCORRECT
Use when ANY of the following is true:
- A public interface from the code patch is missing
- A private/internal element is incorrectly documented as public
- A documented interface does not exist in the code patch
- Interface details are wrong (wrong name, wrong parameters, wrong types)

### NOT_APPLICABLE
Use when:
- The code patch contains no functional code (documentation only)
- The code patch only modifies private/internal code with no public interfaces

## Output Format

Respond ONLY with a valid JSON object. Do not include markdown formatting, backticks, or additional text.

```
{
  "correctness_label": "CORRECT" | "INCORRECT" | "NOT_APPLICABLE",
  "issues": [
    "Short description of issue 1",
    "Short description of issue 2"
  ],
  "explanation": "2-5 sentences explaining the decision, referencing the code patch and specific interfaces as needed."
}
```

### Field Specifications

- **correctness_label**: Exactly one of: "CORRECT", "INCORRECT", or "NOT_APPLICABLE"
- **issues**: Array of short strings describing problems. Empty array if no issues.
- **explanation**: Natural language explanation (2-5 sentences) that:
  - References the code patch
  - Cites specific interfaces when discussing issues
  - Explains why the label was chosen

## Examples

### Example 1: Correct Public Interfaces

<example_code_patch>
```python
diff --git a/services/user.py b/services/user.py
+class UserService:
+    def __init__(self, db):
+        self.db = db
+
+    def _validate_email(self, email):
+        return '@' in email
+
+    def create_user(self, name, email):
+        if not self._validate_email(email):
+            raise ValueError("Invalid email")
+        return self.db.insert({"name": name, "email": email})
+
+def get_user_by_id(user_id):
+    return db.find(user_id)
```
</example_code_patch>

<example_public_interfaces>
```
* path: /app/services/user.py
  name: user.UserService
  type: class
  inputs: db: Database
  outputs: UserService instance
  description: Service class for user management operations.

* path: /app/services/user.py
  name: user.UserService.create_user
  type: method
  inputs: name: str, email: str
  outputs: dict
  description: Creates a new user with the given name and email.

* path: /app/services/user.py
  name: user.get_user_by_id
  type: function
  inputs: user_id: int
  outputs: User
  description: Retrieves a user by their ID.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly identify all public elements: the UserService class, its public create_user method, and the standalone get_user_by_id function. The private _validate_email method is correctly excluded because it starts with an underscore, indicating it is private in Python."
}
```
</example_output>

### Example 2: Incorrect - Missing Public Interface

<example_code_patch>
```go
diff --git a/pkg/auth/auth.go b/pkg/auth/auth.go
+func ValidateToken(token string) bool {
+    return len(token) > 0
+}
+
+func GenerateToken(userId int) string {
+    return fmt.Sprintf("token_%d", userId)
+}
+
+func parseToken(token string) map[string]string {
+    return nil
+}
```
</example_code_patch>

<example_public_interfaces>
```
* path: /app/pkg/auth/auth.go
  name: auth.ValidateToken
  type: function
  inputs: token: string
  outputs: bool
  description: Validates if a token is valid.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Missing public interface: GenerateToken function is public (starts with uppercase) but not documented"
  ],
  "explanation": "The public interfaces are incomplete. In Go, functions starting with uppercase letters are public. ValidateToken is correctly documented, but GenerateToken is also public and is missing from the list. The parseToken function is correctly excluded as it starts with lowercase (private in Go)."
}
```
</example_output>

### Example 3: Incorrect - Private Element Included

<example_code_patch>
```javascript
diff --git a/src/utils/formatter.js b/src/utils/formatter.js
+export function formatCurrency(amount) {
+  return `$${amount.toFixed(2)}`;
+}
+
+function roundToDecimals(num, decimals) {
+  return Number(num.toFixed(decimals));
+}
+
+const DEFAULT_CURRENCY = 'USD';
```
</example_code_patch>

<example_public_interfaces>
```
* path: /app/src/utils/formatter.js
  name: formatter.formatCurrency
  type: function
  inputs: amount: number
  outputs: string
  description: Formats a number as currency string.

* path: /app/src/utils/formatter.js
  name: formatter.roundToDecimals
  type: function
  inputs: num: number, decimals: number
  outputs: number
  description: Rounds a number to specified decimal places.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Private element incorrectly included: roundToDecimals is not exported and should not be documented as a public interface"
  ],
  "explanation": "The public interfaces incorrectly include roundToDecimals, which is a private function (no export keyword). In JavaScript, only elements with 'export' are public. formatCurrency is correctly documented as it has the export keyword. DEFAULT_CURRENCY is correctly excluded as constants should not be documented."
}
```
</example_output>

### Example 4: Incorrect - Interface Not in Code Patch

<example_code_patch>
```java
diff --git a/src/main/java/com/app/Calculator.java b/src/main/java/com/app/Calculator.java
+public class Calculator {
+    public int add(int a, int b) {
+        return a + b;
+    }
+}
```
</example_code_patch>

<example_public_interfaces>
```
* path: /app/src/main/java/com/app/Calculator.java
  name: com.app.Calculator
  type: class
  inputs: None
  outputs: Calculator instance
  description: Basic calculator class.

* path: /app/src/main/java/com/app/Calculator.java
  name: com.app.Calculator.add
  type: method
  inputs: a: int, b: int
  outputs: int
  description: Adds two integers.

* path: /app/src/main/java/com/app/Calculator.java
  name: com.app.Calculator.subtract
  type: method
  inputs: a: int, b: int
  outputs: int
  description: Subtracts two integers.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Interface not in code patch: subtract method does not exist in the code patch"
  ],
  "explanation": "The public interfaces include a subtract method that does not exist in the code patch. The code patch only introduces the Calculator class with an add method. The subtract method appears to be hallucinated or from a different version of the code."
}
```
</example_output>

### Example 5: Not Applicable - No Public Interfaces

<example_code_patch>
```python
diff --git a/internal/helpers.py b/internal/helpers.py
+def _format_string(text):
+    return text.strip().lower()
+
+def _log_message(msg):
+    print(f"[LOG] {msg}")
```
</example_code_patch>

<example_public_interfaces>
```
N/A

Reasoning: All functions are private (start with underscore).
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly indicate N/A because all functions in the code patch are private (prefixed with underscore in Python). There are no public interfaces to document."
}
```
</example_output>

### Example 6: Ruby - Correct with Class Methods and Private

<example_code_patch>
```ruby
diff --git a/lib/payment_processor.rb b/lib/payment_processor.rb
+class PaymentProcessor
+  attr_reader :gateway
+
+  def initialize(gateway)
+    @gateway = gateway
+  end
+
+  def process_payment(amount, card)
+    validate_amount(amount)
+    gateway.charge(amount, card)
+  end
+
+  def self.supported_currencies
+    ['USD', 'EUR', 'GBP']
+  end
+
+  private
+
+  def validate_amount(amount)
+    raise ArgumentError if amount <= 0
+  end
+end
```
</example_code_patch>

<example_public_interfaces>
```
* path: /app/lib/payment_processor.rb
  name: PaymentProcessor
  type: class
  inputs: gateway: Gateway
  outputs: PaymentProcessor instance
  description: Processes payments through a gateway.

* path: /app/lib/payment_processor.rb
  name: PaymentProcessor.gateway
  type: method
  inputs: None
  outputs: Gateway
  description: Getter for gateway attribute.

* path: /app/lib/payment_processor.rb
  name: PaymentProcessor.process_payment
  type: method
  inputs: amount: Numeric, card: Card
  outputs: Transaction
  description: Processes a payment with the given amount and card.

* path: /app/lib/payment_processor.rb
  name: PaymentProcessor.supported_currencies
  type: method
  inputs: None
  outputs: Array[String]
  description: Returns list of supported currency codes.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The public interfaces correctly identify all public elements: the PaymentProcessor class, the gateway attribute reader created by attr_reader, the instance method process_payment, and the class method supported_currencies. The private validate_amount method is correctly excluded as it appears after the private keyword in Ruby."
}
```
</example_output>

### Example 7: C++ - Incorrect Missing Public Method

<example_code_patch>
```cpp
diff --git a/src/core/cache.hpp b/src/core/cache.hpp
+namespace core {
+
+class Cache {
+public:
+    Cache(size_t capacity);
+
+    void set(const std::string& key, const std::string& value);
+    std::string get(const std::string& key) const;
+    void clear();
+
+private:
+    size_t capacity_;
+    std::unordered_map<std::string, std::string> data_;
+
+    void evict_oldest();
+};
+
+}
```
</example_code_patch>

<example_public_interfaces>
```
* path: /app/src/core/cache.hpp
  name: core::Cache
  type: class
  inputs: capacity: size_t
  outputs: Cache instance
  description: LRU cache implementation.

* path: /app/src/core/cache.hpp
  name: core::Cache.set
  type: method
  inputs: key: const std::string&, value: const std::string&
  outputs: void
  description: Stores a key-value pair in the cache.

* path: /app/src/core/cache.hpp
  name: core::Cache.get
  type: method
  inputs: key: const std::string&
  outputs: std::string
  description: Retrieves a value from the cache by key.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Missing public interface: clear method is public but not documented"
  ],
  "explanation": "The public interfaces are incomplete. In C++, all members in the public section are public interfaces. The set and get methods are correctly documented, but the clear method is also in the public section and is missing from the list. The evict_oldest method is correctly excluded as it is in the private section."
}
```
</example_output>

### Example 8: C# - Incorrect Private Element Included

<example_code_patch>
```csharp
diff --git a/src/Services/EmailService.cs b/src/Services/EmailService.cs
+namespace MyApp.Services
+{
+    public class EmailService
+    {
+        private readonly IEmailProvider provider;
+
+        public EmailService(IEmailProvider provider)
+        {
+            this.provider = provider;
+        }
+
+        public async Task SendEmail(string to, string subject, string body)
+        {
+            ValidateEmail(to);
+            await provider.SendAsync(to, subject, body);
+        }
+
+        internal bool ValidateEmail(string email)
+        {
+            return email.Contains("@");
+        }
+
+        private string FormatBody(string body)
+        {
+            return body.Trim();
+        }
+    }
+}
```
</example_code_patch>

<example_public_interfaces>
```
* path: /app/src/Services/EmailService.cs
  name: MyApp.Services.EmailService
  type: class
  inputs: provider: IEmailProvider
  outputs: EmailService instance
  description: Service for sending emails.

* path: /app/src/Services/EmailService.cs
  name: MyApp.Services.EmailService.SendEmail
  type: method
  inputs: to: string, subject: string, body: string
  outputs: Task
  description: Sends an email to the specified recipient.

* path: /app/src/Services/EmailService.cs
  name: MyApp.Services.EmailService.ValidateEmail
  type: method
  inputs: email: string
  outputs: bool
  description: Validates an email address format.
```
</example_public_interfaces>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Private element incorrectly included: ValidateEmail is marked internal, not public, and should not be documented as a public interface"
  ],
  "explanation": "The public interfaces incorrectly include ValidateEmail, which has internal visibility in C#. Internal members are only accessible within the same assembly and should not be documented as public interfaces. Only the EmailService class and SendEmail method should be documented. The FormatBody method is correctly excluded as it is private."
}
```
</example_output>

## Important Reminders

- Apply the specific language's visibility rules consistently
- Check that ALL public interfaces from the code patch are documented
- Verify NO private/internal elements are incorrectly included
- Ensure all documented interfaces actually exist in the code patch
- Focus on callable interfaces (functions, methods, classes), not constants or types

---
---
---

## YOUR ACTUAL INPUT HERE

**Code Patch (Required):**

<code_patch>
{{code_patch}}
</code_patch>

**Public Interfaces to Evaluate (Required):**

<public_interfaces>
{{public_interfaces}}
</public_interfaces>
