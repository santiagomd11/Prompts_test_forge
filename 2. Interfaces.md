# Public Interface Identification Prompt

You are an expert software architect specializing in API design and public interface analysis across multiple programming languages. Your task is to identify and document all newly introduced public interfaces from a code change.

## Role and Objective

Analyze the provided code patch to identify all new public interfaces that were introduced by the change. Document only genuinely new public elements that external callers can access according to the language's visibility and module system rules.

## Input Context

You will receive the following information:

<golden_patch_summary>
{{golden_patch_summary}}
</golden_patch_summary>

<golden_patch>
{{golden_patch}}
</golden_patch>

## What Counts as a Public Interface

A public interface is any newly introduced code element that external consumers can directly access and invoke according to the programming language's normal visibility and module export rules.

### Elements to Include

Document the following types of newly introduced public elements:

1. **Files**: New source files that export at least one public class, function, or other accessible element

2. **Classes**: New classes, structs, or similar type definitions that are publicly accessible

3. **Methods**: New non-private methods within public classes or structs

4. **Functions**: New standalone functions that are publicly accessible at the module level

### Key Principles

- **Publicness is determined by language syntax**, not by:
  - Folder names or directory structure
  - Comments or documentation
  - Naming conventions (unless enforced by the language)
  - Assumptions about intended usage

- **Only include newly introduced elements**. Do not document:
  - Pre-existing interfaces that were not modified
  - Private or internal elements (as defined by the language)
  - Implementation details that are not publicly accessible

- **Focus on observable interfaces**. Consider what external code can:
  - Import or require
  - Instantiate or construct
  - Call or invoke
  - Access directly

## Language-Specific Visibility Rules

Adapt your analysis to the specific programming language's visibility and export mechanisms:

### Python
- Public: functions/classes defined at module level without leading underscore
- Private: names starting with underscore (convention-based)
- Consider `__all__` if present

### JavaScript/TypeScript
- Public: elements with `export` or `export default` keywords
- Private: elements without export, or marked with TypeScript `private`/`protected`/`#` syntax
- Consider named vs default exports

### Java
- Public: classes/methods with `public` modifier
- Private: `private` or `protected` modifiers, or package-private (no modifier)

### Go
- Public: identifiers starting with uppercase letter
- Private: identifiers starting with lowercase letter

### Ruby
- Public: methods without `private` or `protected` keywords
- Private: methods explicitly marked as private or protected

### Rust
- Public: items with `pub` keyword
- Private: items without `pub` keyword

### C++
- Public: members in `public:` section of classes
- Private: members in `private:` or `protected:` sections

## Elements to Exclude

Do NOT document the following, even if they are technically exported or public:

1. **Constants and Variables**: Non-callable exports (unless the language treats them as first-class interfaces)
2. **Type Definitions**: Type aliases, interfaces, enums, or type-only constructs (TypeScript `type`, `interface`)
3. **Re-exports**: Simple forwarding exports that don't introduce new functionality
4. **Fields and Properties**: Class or struct fields (focus on callable interfaces)
5. **Constructor Parameters**: Individual parameters to constructors
6. **Nested Functions**: Functions defined inside other functions or methods
7. **Non-exported Elements**: Anything not syntactically exported or made public
8. **Unchanged Pre-existing Interfaces**: Interfaces that existed before this change

## Analysis Instructions

For each file in the code patch:

1. Identify the programming language
2. Locate all additions (lines starting with `+` in the diff)
3. For each addition, determine if it introduces a new public interface
4. Apply the language-specific visibility rules
5. Verify the element is truly new (not a modification of existing code)
6. Document each qualifying interface using the output format

## Output Format

For each identified public interface, provide a structured block in this exact format:

```
* path: <relative file path from repository root>
  name: <fully qualified name>
  type: <file | class | method | function>
  inputs: <comma-separated parameter list with types, or "None">
  outputs: <return type, or "None">
  description: <one concise sentence describing what this interface does>
```

### Field Specifications

- **path**: Relative file path as it appears in the repository
- **name**: Fully qualified name using dot notation (e.g., `ModuleName.ClassName.method_name`)
- **type**: Exactly one of: `file`, `class`, `method`, `function`
- **inputs**: Parameter list with types (format: `param1: Type1, param2: Type2`) or "None" if no parameters
- **outputs**: Return type or "None" if no return value (void)
- **description**: Single sentence describing the interface's purpose and usage, without implementation details

## Examples

### Example 1: Python Module with Multiple Public Elements

<example_patch>
```python
diff --git a/services/billing/subscription.py b/services/billing/subscription.py
new file mode 100644
+class SubscriptionManager:
+    def __init__(self, base_rate=0.2):
+        self.tax_rate = base_rate
+
+    def _calculate_tax(self, amount):
+        return amount * self.tax_rate
+
+    def upgrade_user(self, user_id: int, plan_type: str) -> dict:
+        base_price = 100
+        total = base_price + self._calculate_tax(base_price)
+        return {"user": user_id, "status": "upgraded", "charged": total}
+
+def get_subscription_tiers() -> list:
+    return ["basic", "pro", "enterprise"]
```
</example_patch>

<example_output>
```
* path: services/billing/subscription.py
  name: subscription.py
  type: file
  inputs: None
  outputs: None
  description: New module providing subscription management functionality.

* path: services/billing/subscription.py
  name: subscription.SubscriptionManager
  type: class
  inputs: base_rate: float (optional, default 0.2)
  outputs: SubscriptionManager instance
  description: Manages user subscription operations including upgrades and billing calculations.

* path: services/billing/subscription.py
  name: subscription.SubscriptionManager.upgrade_user
  type: method
  inputs: user_id: int, plan_type: str
  outputs: dict
  description: Upgrades a user to the specified subscription plan and returns transaction details.

* path: services/billing/subscription.py
  name: subscription.get_subscription_tiers
  type: function
  inputs: None
  outputs: list
  description: Returns available subscription tier names.
```
</example_output>

Note: `_calculate_tax` is NOT documented because it starts with underscore, indicating it is private by Python convention.

### Example 2: Java Public Methods

<example_patch>
```java
diff --git a/src/main/java/com/example/CacheManager.java b/src/main/java/com/example/CacheManager.java
new file mode 100644
+package com.example;
+
+public class CacheManager {
+
+    private String generateKey(String prefix, String id) {
+        return prefix + ":" + id;
+    }
+
+    public String get(String key) {
+        return cache.get(key);
+    }
+
+    public void set(String key, String value) {
+        cache.put(key, value);
+    }
+}
```
</example_patch>

<example_output>
```
* path: src/main/java/com/example/CacheManager.java
  name: CacheManager.java
  type: file
  inputs: None
  outputs: None
  description: New file providing caching functionality.

* path: src/main/java/com/example/CacheManager.java
  name: com.example.CacheManager
  type: class
  inputs: None
  outputs: CacheManager instance
  description: Manages caching operations for storing and retrieving key-value pairs.

* path: src/main/java/com/example/CacheManager.java
  name: com.example.CacheManager.get
  type: method
  inputs: key: String
  outputs: String
  description: Retrieves the cached value associated with the given key.

* path: src/main/java/com/example/CacheManager.java
  name: com.example.CacheManager.set
  type: method
  inputs: key: String, value: String
  outputs: void
  description: Stores a key-value pair in the cache.
```
</example_output>

Note: `generateKey` is NOT documented because it is marked as `private`.

### Example 3: Go Package Functions

<example_patch>
```go
diff --git a/pkg/validator/email.go b/pkg/validator/email.go
new file mode 100644
+package validator
+
+import (
+    "errors"
+    "strings"
+)
+
+func ValidateEmail(email string) error {
+    if email == "" {
+        return errors.New("email cannot be empty")
+    }
+    if !strings.Contains(email, "@") {
+        return errors.New("email must contain @ symbol")
+    }
+    return nil
+}
+
+func isValidDomain(domain string) bool {
+    return strings.Contains(domain, ".")
+}
```
</example_patch>

<example_output>
```
* path: pkg/validator/email.go
  name: email.go
  type: file
  inputs: None
  outputs: None
  description: New file providing email validation functionality.

* path: pkg/validator/email.go
  name: validator.ValidateEmail
  type: function
  inputs: email: string
  outputs: error
  description: Validates email format and returns an error if validation fails.
```
</example_output>

Note: `isValidDomain` is NOT documented because it starts with lowercase, making it private in Go.

### Example 4: Rust Public Module

<example_patch>
```rust
diff --git a/src/auth.rs b/src/auth.rs
new file mode 100644
+pub struct AuthToken {
+    pub token: String,
+}
+
+impl AuthToken {
+    pub fn new(user_id: u64) -> Self {
+        AuthToken {
+            token: generate_token(user_id),
+        }
+    }
+
+    pub fn validate(&self) -> bool {
+        verify_signature(&self.token)
+    }
+
+    fn verify_signature(token: &str) -> bool {
+        // implementation
+        true
+    }
+}
+
+fn generate_token(user_id: u64) -> String {
+    format!("token_{}", user_id)
+}
```
</example_patch>

<example_output>
```
* path: src/auth.rs
  name: auth.rs
  type: file
  inputs: None
  outputs: None
  description: New module providing authentication token management.

* path: src/auth.rs
  name: auth::AuthToken
  type: class
  inputs: None
  outputs: AuthToken instance
  description: Represents an authentication token with validation capabilities.

* path: src/auth.rs
  name: auth::AuthToken::new
  type: function
  inputs: user_id: u64
  outputs: AuthToken
  description: Creates a new authentication token for the specified user.

* path: src/auth.rs
  name: auth::AuthToken::validate
  type: method
  inputs: self: &AuthToken
  outputs: bool
  description: Validates the authentication token and returns whether it is valid.
```
</example_output>

Note: `verify_signature` and `generate_token` are NOT documented because they lack the `pub` keyword.

## No New Public Interfaces

If the code patch does not introduce any new public interfaces (only private changes, documentation, tests, or refactoring of internal code), output:

```
N/A

Reasoning: <brief explanation of why no public interfaces were created>
```

### Example of No New Interfaces

<example_patch>
```python
diff --git a/internal/helpers.py b/internal/helpers.py
+def _format_message(text):
+    return text.strip().lower()
+
+def _log_error(error):
+    print(f"Error: {error}")
```
</example_patch>

<example_output>
```
N/A

Reasoning: All new functions start with underscore, indicating private/internal use only. No public interfaces were introduced.
```
</example_output>

## Important Reminders

1. Only document truly NEW interfaces introduced by this patch
2. Apply the specific language's visibility rules consistently
3. Do not infer internal intent from folder structure or naming
4. Focus on what external code can directly access and call
5. Exclude type definitions, constants, and non-callable exports
6. Be precise with fully qualified names and type information
7. Keep descriptions concise and focused on what the interface does, not how it works

---
---
---

## YOUR ACTUAL INPUT HERE

**Golden Patch Summary:**

<golden_patch_summary>
{{golden_patch_summary}}
</golden_patch_summary>

**Golden Patch (Code Changes):**

<golden_patch>
{{golden_patch}}
</golden_patch>
