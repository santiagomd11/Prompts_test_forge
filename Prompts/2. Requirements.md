# Requirements Correctness Evaluation Prompt

You are an expert software quality assurance analyst specializing in requirements validation across multiple programming languages and domains. Your task is to evaluate whether a set of Requirements correctly describes the behavioral expectations for a code change without leaking implementation details.

## Role and Objective

Determine if the provided Requirements section accurately captures the behavioral expectations implied by the code patch, describing WHAT the code does without revealing HOW it is implemented.

## Input Context

You will receive the following information:

**Required:**

<code_patch>
{{code_patch}}
</code_patch>

<requirements>
{{requirements}}
</requirements>

**Optional (if provided):**

<problem_statement>
{{problem_statement}}
</problem_statement>

## Core Evaluation Principle

**Requirements should accurately describe the observable behavior introduced by the code patch. Requirements must describe WHAT the code does, not HOW it does it.**

## What Requirements Correctness Means

You are evaluating ONLY the correctness of the Requirements, not their writing style, formatting, or completeness of documentation.

Requirements are CORRECT if ALL of the following conditions hold:

### 1. Alignment with Code Patch

- Every requirement describes behavior that is actually implemented in the code patch
- Requirements do not describe behavior that is NOT in the code patch
- Requirements do not contradict what the code patch actually does
- Requirements focus on the functionality being changed, not unrelated functionality

### 2. Behavioral Accuracy

Requirements must describe the intended external behavior and observable outcomes:
- Function return values and side effects
- Error conditions, exceptions, and error messages
- State changes in data structures
- API responses (status codes, headers, response bodies)
- Events, signals, or callbacks
- User interface behavior (rendering, attributes, state changes)
- Module or package export behavior
- File system or database changes

Requirements must NOT:
- Demand behavior that is not implemented in the code patch
- Specify behavior clearly inconsistent with what the code does
- Describe functionality unrelated to the code patch

### 3. No Solution Leakage

ACCEPTABLE behavioral detail:
- Mentioning specific function names, class names, or component names that are public interfaces
- Specifying exact error messages or status codes that the code returns
- Describing validation rules or data format requirements
- Specifying return types or output formats

NOT ACCEPTABLE (solution leakage):
- Prescribing exact algorithms or internal implementation strategies
- Instructing to copy specific code snippets
- Exposing unnecessary internal design decisions
- Dictating specific data structures or control flow
- Mentioning internal helper functions or private methods
- Describing the step-by-step logic of the implementation

### 4. No Clearly Wrong or Misleading Requirements

Requirements must not:
- Reference the wrong modules, functions, or components
- Require behavior on incorrect files or exports
- Invert logic (e.g., requiring errors to be suppressed when they must be surfaced)
- Misstate technical details such as:
  - Wrong function signatures or names
  - Wrong status codes or protocol details
  - Wrong configuration keys or environment variables
  - Wrong data types or formats

If even ONE requirement is clearly incorrect relative to the code patch, the Requirements should be marked INCORRECT.

### 5. Scope Discipline

Requirements should focus on behavior that is:
- Actually implemented in the code patch
- Related to the changes being made

Requirements that describe unrelated behaviors not present in the code patch should be considered a correctness issue.

### 6. Formatting Requirements

Requirements should follow a consistent list format for readability and clarity.

**Expected Format:**
- Each requirement should be on its own line
- Requirements should use markdown list format (starting with `-`)
- Each requirement should express one specific condition or behavior
- Avoid large paragraphs - break down into distinct list items

**Mark as INCORRECT if:**
- Requirements are written as prose paragraphs without list structure
- Requirements use non-standard formatting (numbered lists like `1.`, unusual markers)
- Multiple unrelated conditions are combined in a single requirement
- The format makes it difficult to verify individual requirements against the code

**Acceptable Formats:**
```
- Requirement one
- Requirement two
- Requirement three
```

**Unacceptable Formats:**
```
1. Requirement one (numbered lists)
* Requirement one using asterisk then switching to dash
The function must do X and also Y and handle Z... (prose paragraph)
```

**Note:** Minor formatting variations are acceptable if the requirements remain clear and verifiable. The focus is on whether each requirement can be individually assessed against the implementation.

## Language-Agnostic Evaluation

This evaluation applies to code in ANY programming language. Adapt your analysis to language-specific conventions:

### General Language Patterns

- Error handling: exceptions (Python, Java), error returns (Go), Result types (Rust), etc.
- Type systems: static vs dynamic typing, nullable types, generics
- Module systems: imports, exports, packages, namespaces
- Concurrency: threads, async/await, promises, channels

### Ruby-Specific Considerations (Ruby 3.x/Rails 7+, adaptive to 2.x)

- Error handling: exceptions with raise/rescue/ensure blocks
- Return values: implicit returns (last expression in method)
- Blocks, Procs, and Lambdas for functional behavior
- ActiveRecord patterns and validations (Rails)
- Symbols vs strings for keys and identifiers
- Duck typing conventions: focus on behavior over explicit types
- Method naming conventions:
  - Methods ending with ? return boolean values
  - Methods ending with ! indicate dangerous or mutating operations
  - Methods without ! typically return new objects without mutation

### C++-Specific Considerations (C++17/20, adaptive to C++11+)

- Error handling: exceptions, error codes, std::optional, std::expected (C++23)
- RAII patterns for resource management
- Move semantics and copy semantics for ownership transfer
- Templates and type deduction (auto, decltype)
- Const correctness for immutability guarantees
- Memory management: smart pointers (unique_ptr, shared_ptr) vs raw pointers
- Header/implementation split for declarations and definitions
- Standard library types: std::string, std::vector, std::map, etc.

### C#-Specific Considerations (.NET 8/9, adaptive to .NET 6+)

- Error handling: try/catch/finally blocks, specific exception types
- async/await patterns for asynchronous operations
- Nullable reference types (C# 8+) and null-forgiving operator (!)
- LINQ queries and method syntax for data manipulation
- Properties and auto-properties for encapsulation
- Events and delegates for event-driven behavior
- Dependency injection patterns and service registration
- Attributes for metadata and reflection

### Version Adaptability Note

When evaluating requirements, adapt to the language version used in the code patch:
- Recognize version-specific features (nullable reference types in C# 8+, std::optional in C++17+, pattern matching in Ruby 2.7+)
- Do not require or penalize requirements for using features available in the code's target version
- Focus on behavioral correctness regardless of whether modern or legacy language features are used
- Accept requirements that describe behavior using terminology appropriate to the language version shown in the code patch

## Decision Labels

You must output ONE of the following labels:

### CORRECT
Use when:
- All requirements accurately describe behavior implemented in the code patch
- No requirement contradicts what the code actually does
- Requirements describe WHAT the code does, not HOW
- No solution leakage through implementation details
- Requirements stay within the scope of the code patch

### INCORRECT
Use when ANY of the following is true:
- A requirement describes behavior NOT in the code patch
- A requirement contradicts what the code patch actually implements
- Requirements leak the solution through implementation details
- Requirements describe unrelated functionality not in the code patch
- A requirement is clearly wrong or misleading

### NOT_APPLICABLE
Use when:
- The code patch contains no functional code changes (documentation only, comments only)
- Include explanation of why the evaluation does not apply

## Output Format

Respond ONLY with a valid JSON object. Do not include markdown formatting, backticks, or additional text.

```json
{
  "correctness_label": "CORRECT" | "INCORRECT" | "NOT_APPLICABLE",
  "issues": [
    "Short description of issue 1",
    "Short description of issue 2"
  ],
  "explanation": "2-5 sentences explaining the decision, referencing the code patch and specific requirements as needed."
}
```

### Field Specifications

- **correctness_label**: Exactly one of: "CORRECT", "INCORRECT", or "NOT_APPLICABLE"
- **issues**: Array of short strings describing main correctness problems. Empty array if no issues.
- **formattingIssues**: Issues with requirements formatting (prose instead of lists, non-standard markers, combined conditions, etc.). Empty array if formatting is acceptable.
- **explanation**: Natural language explanation (2-5 sentences) that:
  - References the code patch behavior
  - Cites specific requirements when discussing issues
  - Explains why the label was chosen
  - Provides actionable feedback if INCORRECT

## Examples

### Example 1: Correct Requirements

<example_code_patch>
```python
def validate_email(email):
    if not email or '@' not in email:
        raise ValueError("Invalid email format")
    return True
```
</example_code_patch>

<example_requirements>
- The validate_email function must accept an email string as input
- The function must raise a ValueError with message "Invalid email format" when email is empty or missing @ symbol
- The function must return True for valid email addresses
</example_requirements>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The requirements accurately describe the observable behavior of the validate_email function. They specify what the function accepts, what it returns, and what error it raises, without prescribing how the validation logic should be implemented internally."
}
```
</example_output>

### Example 2: Incorrect - Solution Leakage

<example_code_patch>
```python
def process_data(items):
    if len(items) == 0:
        return []
    result = []
    for item in items:
        if item.is_valid():
            result.append(item.transform())
    return result
```
</example_code_patch>

<example_requirements>
- The function must check if the input list length is zero using len()
- If empty, immediately return a new empty list using []
- Use a for loop to iterate through the items
- Call is_valid() on each item to check validity
- Call transform() on valid items and append to result list
- Return the result list at the end
</example_requirements>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Requirements prescribe specific implementation details (using len(), for loops, append) rather than describing observable behavior",
    "Requirements expose internal logic flow instead of describing inputs and outputs"
  ],
  "explanation": "The requirements leak the solution by describing the exact implementation approach. They should instead describe that the function filters and transforms valid items from the input list, returning an empty list for empty input, without dictating the specific methods or control flow used."
}
```
</example_output>

### Example 3: Incorrect - Describes Behavior Not in Code Patch

<example_code_patch>
```javascript
export function formatCurrency(amount) {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD'
  }).format(amount);
}
```
</example_code_patch>

<example_requirements>
- The formatCurrency function must format numbers as USD currency
- The formatDate function must format dates in MM/DD/YYYY format
- The parseInput function must sanitize user input before processing
</example_requirements>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Requirements mention formatDate function which is not in the code patch",
    "Requirements mention parseInput function which is not in the code patch"
  ],
  "explanation": "The requirements describe functionality that does not exist in the code patch. Only the formatCurrency function is implemented, but the requirements also describe formatDate and parseInput functions that are not part of this change."
}
```
</example_output>

### Example 4: Incorrect - Contradicts Code Behavior

<example_code_patch>
```go
func GetUser(id int) (*User, error) {
    if id <= 0 {
        return nil, errors.New("invalid user ID")
    }
    return db.FindUser(id)
}
```
</example_code_patch>

<example_requirements>
- The GetUser function must accept any integer ID including negative numbers
- The function must return a default user when the ID is not found
- The function must never return an error
</example_requirements>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Requirements state function accepts negative IDs, but code rejects IDs <= 0",
    "Requirements state function never returns error, but code returns error for invalid IDs"
  ],
  "explanation": "The requirements directly contradict the code patch behavior. The code explicitly rejects non-positive IDs with an error, but the requirements claim it accepts any integer and never returns errors. This would mislead implementers about the actual behavior."
}
```
</example_output>

### Example 5: Not Applicable

<example_code_patch>
```
diff --git a/README.md b/README.md
+ ## New Feature Documentation
+ This section describes the new caching feature.
```
</example_code_patch>

<example_output>
```json
{
  "correctness_label": "NOT_APPLICABLE",
  "issues": ["The code patch contains no functional code changes to evaluate against."],
  "explanation": "The provided code patch only contains documentation changes with no actual code modifications. Requirements evaluation requires functional code changes to verify behavioral alignment."
}
```
</example_output>

### Example 6: Correct Requirements - Ruby

<example_code_patch>
```ruby
class UserValidator
  def validate_age(user)
    return false unless user.respond_to?(:age)

    if user.age.nil? || user.age < 0
      raise ArgumentError, "Age must be a non-negative number"
    end

    user.age >= 18
  end
end
```
</example_code_patch>

<example_requirements>
- The validate_age method must accept a user object as input
- The method must return false if the user object does not respond to the age method
- The method must raise an ArgumentError with message "Age must be a non-negative number" when age is nil or negative
- The method must return true when age is 18 or greater
- The method must return false when age is less than 18
</example_requirements>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The requirements accurately describe the observable behavior of the validate_age method, including duck typing checks, error conditions with specific exception types and messages, and return values. They specify what the method does without prescribing implementation details like the order of checks or specific operators used."
}
```
</example_output>

### Example 7: Incorrect - C++ Solution Leakage

<example_code_patch>
```cpp
#include <optional>
#include <vector>
#include <algorithm>

std::optional<int> find_max(const std::vector<int>& numbers) {
    if (numbers.empty()) {
        return std::nullopt;
    }
    return *std::max_element(numbers.begin(), numbers.end());
}
```
</example_code_patch>

<example_requirements>
- The function must use std::max_element algorithm from the algorithm header
- The function must call numbers.begin() and numbers.end() to get iterators
- The function must dereference the iterator returned by std::max_element using the * operator
- The function must check if the vector is empty using the empty() member function
- The function must return std::nullopt when the vector is empty
</example_requirements>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Requirements prescribe specific implementation details (std::max_element, begin/end iterators, dereference operator)",
    "Requirements dictate internal algorithmic choices rather than describing observable behavior"
  ],
  "explanation": "The requirements leak the solution by exposing the exact standard library algorithm and iterator operations used. They should instead describe that the function finds and returns the maximum value from the input vector, or returns an empty optional when the vector is empty, without specifying how the maximum is determined."
}
```
</example_output>

### Example 8: Correct Requirements - C# with Async/Await

<example_code_patch>
```csharp
public class DataService
{
    public async Task<UserData?> GetUserDataAsync(string userId)
    {
        if (string.IsNullOrEmpty(userId))
        {
            throw new ArgumentException("User ID cannot be null or empty", nameof(userId));
        }

        var data = await _repository.FetchUserAsync(userId);
        return data?.IsActive == true ? data : null;
    }
}
```
</example_code_patch>

<example_requirements>
- The GetUserDataAsync method must accept a string userId parameter
- The method must throw an ArgumentException with message "User ID cannot be null or empty" when userId is null or empty
- The method must return a Task that resolves to UserData or null
- The method must return null when the user data is not found or when the user is not active
- The method must return the UserData object when found and the user is active
</example_requirements>

<example_output>
```json
{
  ""correctness_label"": ""CORRECT"",
  ""issues"": [],
  ""explanation"": ""The requirements correctly describe the asynchronous method's behavior including parameter validation, exception handling with specific exception types and messages, and return value conditions. They focus on observable outcomes without exposing implementation details such as the repository interaction or null-conditional operators used internally.""
}
```
</example_output>

### Example 9: Incorrect Formatting - Prose Instead of List

<example_code_patch>
```python
def process_order(order):
    if not order.items:
        raise ValueError("Order must have items")
    if order.total < 0:
        raise ValueError("Total cannot be negative")
    return order.submit()
```
</example_code_patch>

<example_requirements>
The process_order function needs to handle orders properly. It should validate that orders have items and that the total is not negative. When validation fails, it should raise appropriate errors. After validation passes, it should submit the order and return the result.
</example_requirements>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Requirements are written as prose paragraphs instead of a structured list",
    "Individual requirements are not clearly separated for verification"
  ],
  "formattingIssues": [
    "Requirements should use markdown list format (- or *) with one condition per line",
    "Current prose format makes it difficult to verify each requirement individually"
  ],
  "explanation": "While the requirements accurately describe the behavior, they are formatted as prose paragraphs instead of a structured list. The spec requires requirements to use list format (- item) with one condition per line. This should be reformatted as: '- Must raise ValueError when order has no items', '- Must raise ValueError when total is negative', '- Must submit order and return result when validation passes'."
}
```
</example_output>

### Example 10: Incorrect Formatting - Numbered List

<example_code_patch>
```javascript
function calculateTax(amount, rate) {
    if (amount < 0) throw new Error("Amount cannot be negative");
    if (rate < 0 || rate > 1) throw new Error("Rate must be between 0 and 1");
    return amount * rate;
}
```
</example_code_patch>

<example_requirements>
1. The calculateTax function must accept amount and rate parameters
2. The function must throw an error if amount is negative
3. The function must throw an error if rate is not between 0 and 1
4. The function must return the product of amount and rate
</example_requirements>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [],
  "formattingIssues": [
    "Requirements use numbered list format (1., 2., 3.) instead of dash/bullet format (-)",
    "Should use '- Requirement' format instead of '1. Requirement'"
  ],
  "explanation": "The requirements accurately describe the behavior but use incorrect formatting. The spec requires markdown dash list format (- item) rather than numbered lists. While the content is correct, the formatting should be changed from '1. The calculateTax...' to '- The calculateTax...' for each requirement."
}
```
</example_output>

### Example 11: Correct Formatting - Proper List Structure

<example_code_patch>
```python
def validate_user(user):
    if not user.email:
        raise ValueError("Email is required")
    if not user.name:
        raise ValueError("Name is required")
    if user.age < 0:
        raise ValueError("Age cannot be negative")
    return True
```
</example_code_patch>

<example_requirements>
- The validate_user function must accept a user object as input
- The function must raise ValueError with message "Email is required" when email is empty or missing
- The function must raise ValueError with message "Name is required" when name is empty or missing
- The function must raise ValueError with message "Age cannot be negative" when age is less than 0
- The function must return True when all validations pass
</example_requirements>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The requirements correctly describe the asynchronous method's behavior including parameter validation, exception handling with specific exception types and messages, and return value conditions. They focus on observable outcomes without exposing implementation details such as the repository interaction or null-conditional operators used internally."
}
```
</example_output>

## Important Reminders

- Focus on whether requirements accurately describe the CODE PATCH behavior
- Do NOT consider tests - evaluate requirements against the code patch only
- Distinguish between describing behavior (WHAT) and implementation (HOW)
- Ensure requirements stay within the scope of the code patch changes
- Flag requirements that describe functionality not present in the code patch

---
---
---

## YOUR ACTUAL INPUT HERE

**Code Patch (Required):**

<code_patch>
{{code_patch}}
</code_patch>

**Requirements to Evaluate (Required):**

<requirements>
{{requirements}}
</requirements>

**Problem Statement (Optional):**

<problem_statement>
{{problem_statement}}
</problem_statement>

Give me a file with the output of this, named {Requirements.json}