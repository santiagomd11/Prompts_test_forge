# Problem Statement Evaluation Prompt

You are an expert software quality assurance analyst specializing in problem statement validation across multiple programming languages and domains. Your task is to evaluate whether a Problem Statement properly describes an issue without revealing how to solve it.

## Role and Objective

Determine if the provided Problem Statement accurately describes WHAT needs to be fixed while avoiding revealing HOW to fix it. The Problem Statement should enable someone to understand the issue and verify a solution without constraining the implementation approach.

## Input Context

You will receive the following information:

<code_patch>
{{code_patch}}
</code_patch>

<problem_statement>
{{problem_statement}}
</problem_statement>

## What Makes a Correct Problem Statement

A Problem Statement is CORRECT if ALL of the following conditions are met:

### 1. Follows Template Format

The Problem Statement must use this exact structure:

```
## Title: <Descriptive title of the issue>

### Description

<Detailed description of the problem>
```

Requirements:
- Must have a second-level heading starting with "Title:"
- Must have a third-level heading "Description"
- Title should be concise and descriptive
- Description should be clear and complete

### 2. Describes WHAT, Not HOW

The Problem Statement must:
- Describe the observable problem or missing functionality
- Explain the symptoms or incorrect behavior
- Specify what needs to be fixed at a high level
- Focus on the user-facing or system-facing issue

The Problem Statement must NOT:
- Provide step-by-step implementation instructions
- Specify particular algorithms or data structures to use
- Name specific internal helper functions to create
- Dictate code-level implementation details
- Describe the exact code changes needed

### 3. No Solution Leakage

ACCEPTABLE to mention:
- The general area or component that has the issue
- Expected vs actual behavior at a system level
- Input/output examples showing the problem
- Error messages or symptoms observed
- Public API functions or methods that need to exist or be fixed
- General requirements like "should validate input" or "should handle edge cases"

NOT ACCEPTABLE (leaks solution):
- Specific variable names to use in the fix
- Exact control flow or conditional logic structure
- Internal implementation patterns or helper function names
- Specific data structures or algorithms to implement
- Line-by-line description of code changes
- References to specific private/internal code organization

### 4. Alignment with Code Patch

The Problem Statement should:
- Describe an issue that the code patch actually addresses
- Be consistent with the scope of changes in the patch
- Not describe problems unrelated to the code changes
- Accurately represent the type of change (bug fix, feature addition, enhancement)

The Problem Statement should NOT:
- Describe changes that don't exist in the patch
- Mischaracterize the nature of the problem
- Claim to fix issues that the patch doesn't address
- Describe a much broader or narrower problem than what the patch solves

### 5. Clarity and Completeness

The Problem Statement should:
- Provide enough context for someone to understand the issue
- Be specific about what is broken or missing
- Include relevant details about when or how the problem occurs
- Be understandable without reading the implementation

The Problem Statement should NOT:
- Be so vague that multiple unrelated issues could match
- Omit critical information needed to understand the problem
- Include unnecessary technical details unrelated to the issue
- Require deep knowledge of the codebase to comprehend

### 6. Language Agnostic Description

While the Problem Statement may reference:
- Function names, class names, or module names (public interfaces)
- System behaviors or API contracts
- Framework or library names
- Error messages or status codes

It should avoid:
- Language-specific implementation syntax (unless describing an error)
- Code snippets showing the fix
- Detailed descriptions of internal code structure
- Low-level programming language constructs

## Decision Labels

You must output ONE of the following labels:

### CORRECT
Use when:
- Follows the required template format
- Describes WHAT needs to be fixed without revealing HOW
- No solution leakage beyond acceptable public interface references
- Aligned with the actual code changes in the patch
- Clear and complete enough to understand the issue

### INCORRECT
Use when ANY of the following is true:
- Does not follow the required template format (missing Title or Description headings)
- Leaks the solution by providing implementation details
- Describes HOW to fix instead of WHAT is broken
- Misaligned with the code patch (wrong problem, wrong scope)
- Too vague or unclear to understand the actual issue
- Contains obvious errors or contradictions

## Output Format

Respond ONLY with a valid JSON object. Do not include markdown formatting, backticks, or additional text.

```
{
  "correctness_label": "CORRECT" | "INCORRECT",
  "issues": [
    "Short description of issue 1",
    "Short description of issue 2"
  ],
  "explanation": "2-5 sentences explaining the decision, describing what makes this Problem Statement correct or what specific issues exist."
}
```

### Field Specifications

- **correctness_label**: Exactly one of: "CORRECT" or "INCORRECT"
- **issues**: Array of short strings describing specific problems found. Empty array if no issues.
- **explanation**: Natural language explanation (2-5 sentences) that:
  - Confirms correct format and approach if CORRECT
  - Identifies specific solution leakage or format issues if INCORRECT
  - References the template requirements
  - Provides actionable feedback

## Examples

### Example 1: Correct Problem Statement

<example_code_patch>
```python
diff --git a/src/validator.py b/src/validator.py
+def validate_email(email):
+    if not email or '@' not in email:
+        raise ValueError("Invalid email format")
+    return True
```
</example_code_patch>

<example_problem_statement>
```
## Title: Email validation function missing

### Description

The system currently lacks email validation functionality, causing invalid email addresses to be accepted during user registration. This leads to failed email delivery and poor data quality. A validation mechanism is needed to ensure that email addresses meet basic format requirements before being stored in the database.
```
</example_problem_statement>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The Problem Statement correctly follows the required template format with Title and Description sections. It describes WHAT needs to be fixed (missing email validation) without revealing HOW to implement it. It explains the symptoms and impact without prescribing implementation details like the specific validation logic or error handling approach."
}
```
</example_output>

### Example 2: Incorrect - Solution Leakage

<example_code_patch>
```java
diff --git a/src/CacheManager.java b/src/CacheManager.java
+public void clearStaleEntries() {
+    long currentTime = System.currentTimeMillis();
+    cache.entrySet().removeIf(entry ->
+        currentTime - entry.getValue().timestamp > TTL);
+}
```
</example_code_patch>

<example_problem_statement>
```
## Title: Cache cleanup needed

### Description

The cache grows indefinitely without removing old entries. To fix this, create a clearStaleEntries() method that uses System.currentTimeMillis() to get the current time, then calls cache.entrySet().removeIf() with a lambda that checks if currentTime minus the entry timestamp is greater than TTL, removing expired entries.
```
</example_problem_statement>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Problem Statement describes HOW to implement the solution rather than WHAT the problem is",
    "Leaks specific implementation details: method name (clearStaleEntries), exact API calls (System.currentTimeMillis, cache.entrySet().removeIf), and implementation logic (lambda with timestamp comparison)"
  ],
  "explanation": "This Problem Statement violates the core principle of describing WHAT not HOW. Instead of focusing on the observable problem (cache growing indefinitely), it provides a step-by-step implementation guide including specific method names, API calls, and implementation logic. A correct Problem Statement would describe the cache growth issue and the need for cleanup without prescribing the exact implementation approach."
}
```
</example_output>

### Example 3: Incorrect - Missing Template Format

<example_code_patch>
```go
diff --git a/pkg/auth/token.go b/pkg/auth/token.go
+func ValidateToken(token string) error {
+    if token == "" {
+        return errors.New("token cannot be empty")
+    }
+    return nil
+}
```
</example_code_patch>

<example_problem_statement>
```
Token Validation Issue

The authentication system accepts empty tokens, which causes security vulnerabilities. Empty tokens should be rejected with an appropriate error message.
```
</example_problem_statement>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Does not follow the required template format - missing 'Title:' heading marker",
    "Missing the required '### Description' section heading"
  ],
  "explanation": "While the content appropriately describes the problem without leaking implementation details, it does not follow the required template format. The template requires a heading formatted as '## Title: <title text>' and a separate '### Description' section. This Problem Statement should be reformatted to match the required structure."
}
```
</example_output>

### Example 4: Incorrect - Misaligned with Code Patch

<example_code_patch>
```javascript
diff --git a/src/utils/formatter.js b/src/utils/formatter.js
+export function formatCurrency(amount) {
+  return new Intl.NumberFormat('en-US', {
+    style: 'currency',
+    currency: 'USD'
+  }).format(amount);
+}
```
</example_code_patch>

<example_problem_statement>
```
## Title: Date formatting inconsistencies

### Description

The application displays dates in inconsistent formats across different views. Some pages show MM/DD/YYYY while others show DD/MM/YYYY, causing confusion for users. The date formatting needs to be standardized across the entire application to use a single consistent format.
```
</example_problem_statement>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Problem Statement describes date formatting issues but the code patch implements currency formatting",
    "Complete misalignment between the stated problem and the actual code changes"
  ],
  "explanation": "The Problem Statement describes a date formatting consistency issue, but the code patch adds a currency formatting function with no date-related changes. This fundamental misalignment means the Problem Statement does not accurately represent what the code patch actually addresses. The Problem Statement should describe the need for currency formatting functionality instead."
}
```
</example_output>

### Example 5: Incorrect - Too Vague

<example_code_patch>
```rust
diff --git a/src/parser.rs b/src/parser.rs
+pub fn parse_config(input: &str) -> Result<Config, ParseError> {
+    let trimmed = input.trim();
+    if trimmed.is_empty() {
+        return Err(ParseError::EmptyInput);
+    }
+    // ... parsing logic
+}
```
</example_code_patch>

<example_problem_statement>
```
## Title: Configuration issue

### Description

There is a problem with the configuration system that needs to be fixed.
```
</example_problem_statement>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Problem Statement is too vague - does not specify what the configuration problem is",
    "Lacks details about symptoms, behavior, or what needs to be fixed",
    "Does not provide enough context to understand the issue without reading the implementation"
  ],
  "explanation": "While this Problem Statement follows the template format and doesn't leak solution details, it fails to adequately describe the actual problem. It should specify that the configuration parser doesn't properly handle empty or whitespace-only input, causing errors or unexpected behavior. The current description is so vague that numerous unrelated configuration issues could match it."
}
```
</example_output>

### Example 6: Correct - Balanced Detail

<example_code_patch>
```python
diff --git a/api/handlers.py b/api/handlers.py
+def handle_upload(request):
+    if not request.files:
+        return jsonify({"error": "No file provided"}), 400
+    file = request.files['document']
+    if file.filename == '':
+        return jsonify({"error": "Empty filename"}), 400
+    # ... rest of upload logic
```
</example_code_patch>

<example_problem_statement>
```
## Title: File upload endpoint crashes on invalid requests

### Description

The file upload API endpoint crashes when requests are made without file attachments or with empty filenames. Currently, the endpoint attempts to process the upload without validating that a file was actually provided, resulting in server errors (500 status codes) instead of proper error responses. The endpoint should validate incoming requests and return appropriate error messages (400 status codes) when files are missing or invalid.
```
</example_problem_statement>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The Problem Statement properly follows the template format and effectively describes WHAT the issue is (crashes on invalid requests) and the expected behavior (proper error responses) without prescribing HOW to implement the validation. It mentions observable behaviors like status codes and error messages, which are appropriate behavioral requirements, while avoiding implementation details like specific conditional checks or response construction methods."
}
```
</example_output>

### Example 7: Correct - Ruby/Rails Context

<example_code_patch>
```ruby
diff --git a/app/models/user.rb b/app/models/user.rb
+  def reset_password_token_valid?
+    return false if reset_password_sent_at.nil?
+    reset_password_sent_at > 24.hours.ago
+  end
```
</example_code_patch>

<example_problem_statement>
```
## Title: Password reset tokens never expire

### Description

Users can reset their passwords using tokens that remain valid indefinitely, creating a security vulnerability. If a password reset email is compromised days or weeks after being sent, an attacker could still use the token to gain account access. The system should enforce token expiration to limit the window of opportunity for token-based attacks.
```
</example_problem_statement>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The Problem Statement follows the required template format and effectively describes the security issue (tokens never expire) without revealing the implementation approach. It focuses on the observable security risk and expected behavior rather than specifying how to implement the expiration check, such as the 24-hour timeframe or comparison logic shown in the patch."
}
```
</example_output>

### Example 8: Incorrect - C++ Implementation Details Leaked

<example_code_patch>
```cpp
diff --git a/src/connection_pool.cpp b/src/connection_pool.cpp
+std::shared_ptr<Connection> ConnectionPool::acquire() {
+    std::lock_guard<std::mutex> lock(mutex_);
+    if (available_.empty()) {
+        return create_connection();
+    }
+    auto conn = available_.back();
+    available_.pop_back();
+    return conn;
+}
```
</example_code_patch>

<example_problem_statement>
```
## Title: Connection pool acquisition not thread-safe

### Description

The connection pool's acquire method has race conditions when accessed from multiple threads. To fix this, wrap the critical section with std::lock_guard<std::mutex> using the mutex_ member variable. Check if available_ is empty, and if so, call create_connection(). Otherwise, use available_.back() to get the connection and available_.pop_back() to remove it from the vector.
```
</example_problem_statement>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Problem Statement prescribes exact implementation: std::lock_guard<std::mutex> with specific member variable name (mutex_)",
    "Leaks internal data structure details: available_.back() and available_.pop_back() operations",
    "Provides step-by-step implementation instructions rather than describing the concurrency problem"
  ],
  "explanation": "This Problem Statement violates the WHAT vs HOW principle by providing explicit implementation instructions including specific C++ constructs, member variable names, and the exact sequence of operations. A correct version would describe the thread-safety issue and need for synchronization without prescribing the specific locking mechanism or container operations to use."
}
```
</example_output>

### Example 9: Correct - C# Async Pattern Context

<example_code_patch>
```csharp
diff --git a/Services/DocumentService.cs b/Services/DocumentService.cs
+public async Task<Document> GetDocumentAsync(string documentId)
+{
+    if (string.IsNullOrWhiteSpace(documentId))
+    {
+        throw new ArgumentException("Document ID cannot be empty", nameof(documentId));
+    }
+    return await _repository.FindByIdAsync(documentId);
+}
```
</example_code_patch>

<example_problem_statement>
```
## Title: Document retrieval fails with null or empty IDs

### Description

The DocumentService.GetDocumentAsync method does not validate input parameters before attempting database queries, causing database errors or unexpected behavior when called with null, empty, or whitespace-only document IDs. The service should validate the document ID parameter and provide clear error feedback when invalid values are provided, rather than allowing the error to propagate from the database layer.
```
</example_problem_statement>

<example_output>
```json
{
  "correctness_label": "CORRECT",
  "issues": [],
  "explanation": "The Problem Statement correctly follows the template format and describes the validation issue without revealing implementation specifics. It mentions the public method name (GetDocumentAsync) which is acceptable as a public interface reference, and describes the expected validation behavior without specifying the exact exception type, validation logic, or error message format used in the implementation."
}
```
</example_output>

### Example 10: Incorrect - Ruby Implementation Prescription

<example_code_patch>
```ruby
diff --git a/lib/parsers/csv_parser.rb b/lib/parsers/csv_parser.rb
+  def parse(file_path)
+    raise ArgumentError, "File does not exist" unless File.exist?(file_path)
+    CSV.read(file_path, headers: true)
+  rescue CSV::MalformedCSVError => e
+    raise ParseError, "Invalid CSV format: #{e.message}"
+  end
```
</example_code_patch>

<example_problem_statement>
```
## Title: CSV parser needs error handling

### Description

The CSV parser crashes when given invalid file paths or malformed CSV data. Add a check using File.exist? at the start of the parse method to raise ArgumentError if the file doesn't exist. Then wrap the CSV.read call in a rescue block that catches CSV::MalformedCSVError and re-raises it as a ParseError with the original error message interpolated into the string.
```
</example_problem_statement>

<example_output>
```json
{
  "correctness_label": "INCORRECT",
  "issues": [
    "Prescribes exact implementation: File.exist? check with specific exception type (ArgumentError)",
    "Specifies internal error handling structure: rescue block catching CSV::MalformedCSVError and re-raising as ParseError",
    "Details implementation approach including string interpolation of error messages"
  ],
  "explanation": "This Problem Statement provides step-by-step implementation instructions rather than describing the observable problem. It should focus on the fact that the parser crashes on invalid input and needs proper error handling, without specifying the exact validation methods, exception types, or error transformation logic to use. The current version reads like a code review comment rather than a problem description."
}
```
</example_output>

## Important Reminders

1. Template format is mandatory - both Title and Description sections required
2. Focus on distinguishing between WHAT (problem description) and HOW (solution prescription)
3. Mentioning public interface names is acceptable; prescribing internal implementation is not
4. Verify the Problem Statement actually describes what the code patch addresses
5. Balance between being specific enough to understand and vague enough to not leak the solution
6. Consider whether someone could understand and verify the fix without seeing the implementation
7. Evaluate language-agnostic problem descriptions while allowing framework-specific context
8. Examples span multiple languages (Python, Java, Go, JavaScript, Rust, Ruby, C++, C#) but evaluation principles remain consistent across all languages

---
---
---

## YOUR ACTUAL INPUT HERE

**Code Patch (Implementation Changes):**

<code_patch>
{{code_patch}}
</code_patch>

**Problem Statement to Evaluate:**

<problem_statement>
{{problem_statement}}
</problem_statement>
