You are evaluating the **correctness of a Requirements section** for a **TypeScript/JavaScript code change**.

Your goal is to decide whether the Requirements:

* faithfully reflect the TS/JS Problem Statement and any Project Instructions, and
* correctly guide a contributor/model toward the intended TS/JS behavior **without leaking the exact solution**.

Only evaluate this task when `golden_patch_language` indicates a TypeScript/JavaScript change (for example `"typescript"` or `"javascript"`). If the language is not TS/JS, you must return:

{
"correctness_label": "NOT_APPLICABLE",
"issues": ["The golden patch language is not TypeScript/JavaScript."],
"explanation": "This eval only applies to TypeScript/JavaScript changes."
}

---

## CONTEXT

Commit URL: {{commit_url}}
Golden patch language: {{golden_patch_language}}

**TS/JS diff (golden patch):**

```ts
{{golden_patch}}
```

**Problem Statement (TS/JS)**
This describes the bug or feature to be implemented:

{{problem_statement}}

**Requirements to evaluate**
These are the Requirements written by the contributor/model:

{{requirements}}

**Narrow tests (if any)**
These are tests or behaviors that may be overly specific and only pass for particular solutions (exact order, specific error type, specific string match, etc.):

{{narrow_test_list}}

**Guidance on making narrow tests explicit (if provided):**

{{narrow_into_explicit}}

You may use the diff and problem statement to understand what the tests are likely checking, but your primary focus is whether the Requirements are behaviorally correct and aligned with them.
**Do NOT require the Requirements to describe specific internal refactors, helper functions, or exact implementation steps (e.g., specific helper names, concrete data structures, or particular control-flow decomposition). Correctness is about the external behavior being specified, not the internal structure or algorithm.**

---

## WHAT “CORRECTNESS OF REQUIREMENTS” MEANS (TS/JS CONTEXT)

You only judge **correctness**, not writing style or formatting.

The Requirements are **correct** if ALL of the following hold:

1. **Aligned with the TS/JS Problem Statement**

   * Every required behavior is consistent with the Problem Statement and the TS/JS domain.
   * Requirements do not introduce behavior that contradicts or undermines the intended fix in the relevant modules, functions, classes, or components.
   * Requirements do not restate the bug as the desired behavior (e.g., requiring the old, broken behavior to remain).

2. **Aligned with Project Instructions (when inferable from context)**

   * Requirements do not ask the contributor/model to violate obvious project-wide rules, such as:

     * changing or breaking public API exports that are meant to be stable,
     * bypassing established error handling patterns (e.g., throwing instead of returning `Result`/`Either`-style values, or vice versa),
     * ignoring established typing conventions in TypeScript (e.g., using `any` where the project clearly avoids it).
   * Example of an incorrect requirement:

     * “Convert this function from a named export to a default export” when the surrounding context clearly treats the named export as part of the public API that must remain stable.

3. **Behaviorally Accurate for TS/JS Code**

   * Requirements describe the **intended external behavior** and observable outcomes as they appear in TS/JS:

     * function return values and side effects,
     * thrown errors and error messages,
     * state changes in objects/arrays/stores,
     * HTTP responses (status codes, headers, JSON bodies) from API handlers,
     * events emitted or dispatched,
     * DOM / UI behavior (rendering, attributes, ARIA roles, focus, enabled/disabled state, etc.),
     * module export behavior (what is exported and how it is consumed).
   * Requirements do **not** demand impossible behavior (e.g., contradicting the existing data model or type contracts) or behavior clearly inconsistent with the semantics implied by the Problem Statement and diff.
   * **Do NOT mark Requirements as incorrect just because they omit internal details such as helper function names, refactor boundaries, specific data structures, or concrete control flow, as long as the externally visible behavior is correctly specified.**

4. **Covers Narrow TS/JS Tests When Needed**

   * When tests rely on **narrow conditions** that are not naturally inferable from the Problem Statement, the Requirements must explicitly mention them as behavioral constraints. Examples:

     * The test asserts on a **specific error type or message** thrown or rejected by a Promise.
     * The test checks an **exact order** of elements in an array or serialized output, not just that items are present.
     * The test verifies an **exact log message** or console output.
     * The test expects a specific JSON shape or literal string (e.g., an exact URL, header value, or CSS class).
     * The test depends on a specific behavior of an internal helper that is not obvious from the high-level description (e.g., how a token is normalized before being stored).
   * Mentioning these behaviors is **not** considered “leaking the solution” as long as you describe the behavior, not the exact TS/JS implementation.
   * If such narrow TS/JS behaviors are required by the tests but **not captured** in the Requirements, this is a **correctness problem** (the model will fail tests even if it thinks it followed the Requirements).

5. **No Requirement Is Clearly Wrong or Misleading for the TS/JS Codebase**

   * Requirements do not:

     * Ask to modify or create modules/functions/components that are not actually involved in the change.
     * Require behavior on the wrong file or export (e.g., referring to `FooComponent` when the Problem Statement is clearly about `BarComponent`).
     * Invert logic (e.g., requiring to ignore an error that must be surfaced, or to always throw where the problem says to handle gracefully).
     * Misstate key technical details such as:

       * wrong export style (default vs named) when the tests clearly rely on one,
       * wrong function name or signature,
       * wrong HTTP status code or header,
       * wrong environment variable or configuration key.
   * If even one requirement is **clearly incorrect or misleading** relative to the Problem Statement, TS/JS domain, or tests, the Requirements should be marked **INCORRECT**.

6. **No Solution Leakage Beyond Acceptable Behavioral Detail**

   * It is acceptable (and often necessary) to:

     * Mention specific exported function names, component names, or hooks that are used in tests, if needed so that behavior is testable.
     * Specify required ordering of results when tests depend on it (e.g., “the array must be sorted by timestamp ascending before being returned”).
     * Specify exact error messages, HTTP status codes, or event names when tests assert on them.
   * It is **not acceptable** to:

     * Prescribe an exact algorithm or internal TS/JS implementation when tests only care about the final observable behavior (e.g., “use a Map and then spread it into an array with Object.entries”).
     * Instruct to copy a particular internal code snippet or to mirror another internal implementation line-by-line.
     * Expose unnecessary internal design decisions (e.g., exact private helper decomposition, internal caching approach) that are not required by any publicly observable behavior or tests.
   * When judging correctness, **do NOT penalize Requirements for not mentioning internal helpers or refactors**. Penalize only when they incorrectly force an unnecessary implementation strategy or when they omit necessary observable behavior that tests verify.

7. **Scope Discipline**

   * Requirements should stay focused on behavior that is:

     * motivated by the Problem Statement, or
     * clearly exercised by tests related to this change (e.g., new validation, new UI state, new serialization or routing behavior).
   * If Requirements introduce behaviors that are clearly unrelated to the described TS/JS problem (for example, extra utilities or test-only matchers that do not affect production behavior and are not implied by the Problem Statement), you may treat that as a correctness issue because it misdirects the implementation away from the intended scope.

---

## DECISION

You must output a **single binary judgment** and a short explanation.

### Labels

* `CORRECT`
  Use this when:

  * All requirements are consistent with the TS/JS Problem Statement and context.
  * Narrow TS/JS test behaviors (e.g., specific errors, ordering, log messages, exact JSON shapes) are adequately captured when necessary.
  * There is no clearly incorrect, contradictory, or misleading requirement about the TS/JS behavior.
  * Any detailed behavior (including ordering or precise messages) is strictly tied to what the tests and Problem Statement require.
  * The Requirements are not over-prescriptive about internal implementation beyond what is needed to describe observable behavior.

* `INCORRECT`
  Use this when **any** of the following is true:

  * At least one requirement contradicts the TS/JS Problem Statement or obvious project constraints.
  * Important test-verified behaviors in the TS/JS code (especially narrow conditions) are **missing**.
  * A requirement describes TS/JS behavior that is clearly wrong given the Problem Statement or codebase.
  * The Requirements leak the solution by prescribing unnecessary internal implementation details beyond what is required to describe observable behavior.
  * The Requirements introduce unrelated behaviors that are not supported by the Problem Statement or relevant tests and can mislead the implementation.

---

## OUTPUT FORMAT

Respond **only** with a JSON object of the following shape:

* `correctness_label`: `"CORRECT"`, `"INCORRECT"`, or `"NOT_APPLICABLE"`.
* `issues`: a **list of short strings** describing the main correctness issues. Use an empty list if there are none.
* `explanation`: 2–5 sentences in natural language, referencing the TS/JS Problem Statement and individual requirements as needed.

Example:

{
"correctness_label": "INCORRECT",
"issues": [
"The requirements do not clearly state that previously registered handlers must be fully removed so that stale handlers are not invoked after reconfiguration.",
"The requirements introduce behaviors related to an internal testing helper that are not supported by the Problem Statement and appear unrelated to the routing behavior being fixed."
],
"explanation": "The Problem Statement focuses on ensuring that route handlers are correctly updated so that old handlers are not retained after configuration changes. The current requirements mention updating handlers but do not clearly specify that existing handlers must be removed, which is necessary for the behavior tested (no stale invocations after reconfiguration). Additionally, some requirements introduce test-helper-specific behavior that is unrelated to the described routing issue, which may mislead the implementation away from the intended functional scope."
}